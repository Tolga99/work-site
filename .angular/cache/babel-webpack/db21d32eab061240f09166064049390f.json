{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/t_olg/Desktop/Tolga/Ov/Projets/DevisApp/work-site/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { parallel, HarnessPredicate } from '@angular/cdk/testing';\nimport { MatFormFieldControlHarness } from '@angular/material/form-field/testing/control';\nimport { MatOptionHarness, MatOptgroupHarness } from '@angular/material/core/testing';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nclass _MatSelectHarnessBase extends MatFormFieldControlHarness {\n  constructor() {\n    super(...arguments);\n    this._documentRootLocator = this.documentRootLocatorFactory();\n    this._backdrop = this._documentRootLocator.locatorFor('.cdk-overlay-backdrop');\n  }\n  /** Gets a boolean promise indicating if the select is disabled. */\n\n\n  isDisabled() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this.host()).hasClass(`${_this._prefix}-select-disabled`);\n    })();\n  }\n  /** Gets a boolean promise indicating if the select is valid. */\n\n\n  isValid() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return !(yield (yield _this2.host()).hasClass('ng-invalid'));\n    })();\n  }\n  /** Gets a boolean promise indicating if the select is required. */\n\n\n  isRequired() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this3.host()).hasClass(`${_this3._prefix}-select-required`);\n    })();\n  }\n  /** Gets a boolean promise indicating if the select is empty (no value is selected). */\n\n\n  isEmpty() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this4.host()).hasClass(`${_this4._prefix}-select-empty`);\n    })();\n  }\n  /** Gets a boolean promise indicating if the select is in multi-selection mode. */\n\n\n  isMultiple() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this5.host()).hasClass(`${_this5._prefix}-select-multiple`);\n    })();\n  }\n  /** Gets a promise for the select's value text. */\n\n\n  getValueText() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const value = yield _this6.locatorFor(`.${_this6._prefix}-select-value`)();\n      return value.text();\n    })();\n  }\n  /** Focuses the select and returns a void promise that indicates when the action is complete. */\n\n\n  focus() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this7.host()).focus();\n    })();\n  }\n  /** Blurs the select and returns a void promise that indicates when the action is complete. */\n\n\n  blur() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this8.host()).blur();\n    })();\n  }\n  /** Whether the select is focused. */\n\n\n  isFocused() {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this9.host()).isFocused();\n    })();\n  }\n  /** Gets the options inside the select panel. */\n\n\n  getOptions(filter) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this10._documentRootLocator.locatorForAll(_this10._optionClass.with({ ...(filter || {}),\n        ancestor: yield _this10._getPanelSelector()\n      }))();\n    })();\n  }\n  /** Gets the groups of options inside the panel. */\n\n\n  getOptionGroups(filter) {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this11._documentRootLocator.locatorForAll(_this11._optionGroupClass.with({ ...(filter || {}),\n        ancestor: yield _this11._getPanelSelector()\n      }))();\n    })();\n  }\n  /** Gets whether the select is open. */\n\n\n  isOpen() {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      return !!(yield _this12._documentRootLocator.locatorForOptional(yield _this12._getPanelSelector())());\n    })();\n  }\n  /** Opens the select's panel. */\n\n\n  open() {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(yield _this13.isOpen())) {\n        const trigger = yield _this13.locatorFor(`.${_this13._prefix}-select-trigger`)();\n        return trigger.click();\n      }\n    })();\n  }\n  /**\n   * Clicks the options that match the passed-in filter. If the select is in multi-selection\n   * mode all options will be clicked, otherwise the harness will pick the first matching option.\n   */\n\n\n  clickOptions(filter) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this14.open();\n      const [isMultiple, options] = yield parallel(() => [_this14.isMultiple(), _this14.getOptions(filter)]);\n\n      if (options.length === 0) {\n        throw Error('Select does not have options matching the specified filter');\n      }\n\n      if (isMultiple) {\n        yield parallel(() => options.map(option => option.click()));\n      } else {\n        yield options[0].click();\n      }\n    })();\n  }\n  /** Closes the select's panel. */\n\n\n  close() {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      if (yield _this15.isOpen()) {\n        // This is the most consistent way that works both in both single and multi-select modes,\n        // but it assumes that only one overlay is open at a time. We should be able to make it\n        // a bit more precise after #16645 where we can dispatch an ESCAPE press to the host instead.\n        return (yield _this15._backdrop()).click();\n      }\n    })();\n  }\n  /** Gets the selector that should be used to find this select's panel. */\n\n\n  _getPanelSelector() {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      const id = yield (yield _this16.host()).getAttribute('id');\n      return `#${id}-panel`;\n    })();\n  }\n\n}\n/** Harness for interacting with a standard mat-select in tests. */\n\n\nclass MatSelectHarness extends _MatSelectHarnessBase {\n  constructor() {\n    super(...arguments);\n    this._prefix = 'mat';\n    this._optionClass = MatOptionHarness;\n    this._optionGroupClass = MatOptgroupHarness;\n  }\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatSelectHarness` that meets\n   * certain criteria.\n   * @param options Options for filtering which select instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n\n\n  static with(options = {}) {\n    return new HarnessPredicate(MatSelectHarness, options);\n  }\n\n}\n\nMatSelectHarness.hostSelector = '.mat-select';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport { MatSelectHarness, _MatSelectHarnessBase };","map":{"version":3,"sources":["C:/Users/t_olg/Desktop/Tolga/Ov/Projets/DevisApp/work-site/node_modules/@angular/material/fesm2020/select/testing.mjs"],"names":["parallel","HarnessPredicate","MatFormFieldControlHarness","MatOptionHarness","MatOptgroupHarness","_MatSelectHarnessBase","constructor","arguments","_documentRootLocator","documentRootLocatorFactory","_backdrop","locatorFor","isDisabled","host","hasClass","_prefix","isValid","isRequired","isEmpty","isMultiple","getValueText","value","text","focus","blur","isFocused","getOptions","filter","locatorForAll","_optionClass","with","ancestor","_getPanelSelector","getOptionGroups","_optionGroupClass","isOpen","locatorForOptional","open","trigger","click","clickOptions","options","length","Error","map","option","close","id","getAttribute","MatSelectHarness","hostSelector"],"mappings":"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","sourcesContent":["import { parallel, HarnessPredicate } from '@angular/cdk/testing';\nimport { MatFormFieldControlHarness } from '@angular/material/form-field/testing/control';\nimport { MatOptionHarness, MatOptgroupHarness } from '@angular/material/core/testing';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass _MatSelectHarnessBase extends MatFormFieldControlHarness {\n    constructor() {\n        super(...arguments);\n        this._documentRootLocator = this.documentRootLocatorFactory();\n        this._backdrop = this._documentRootLocator.locatorFor('.cdk-overlay-backdrop');\n    }\n    /** Gets a boolean promise indicating if the select is disabled. */\n    async isDisabled() {\n        return (await this.host()).hasClass(`${this._prefix}-select-disabled`);\n    }\n    /** Gets a boolean promise indicating if the select is valid. */\n    async isValid() {\n        return !(await (await this.host()).hasClass('ng-invalid'));\n    }\n    /** Gets a boolean promise indicating if the select is required. */\n    async isRequired() {\n        return (await this.host()).hasClass(`${this._prefix}-select-required`);\n    }\n    /** Gets a boolean promise indicating if the select is empty (no value is selected). */\n    async isEmpty() {\n        return (await this.host()).hasClass(`${this._prefix}-select-empty`);\n    }\n    /** Gets a boolean promise indicating if the select is in multi-selection mode. */\n    async isMultiple() {\n        return (await this.host()).hasClass(`${this._prefix}-select-multiple`);\n    }\n    /** Gets a promise for the select's value text. */\n    async getValueText() {\n        const value = await this.locatorFor(`.${this._prefix}-select-value`)();\n        return value.text();\n    }\n    /** Focuses the select and returns a void promise that indicates when the action is complete. */\n    async focus() {\n        return (await this.host()).focus();\n    }\n    /** Blurs the select and returns a void promise that indicates when the action is complete. */\n    async blur() {\n        return (await this.host()).blur();\n    }\n    /** Whether the select is focused. */\n    async isFocused() {\n        return (await this.host()).isFocused();\n    }\n    /** Gets the options inside the select panel. */\n    async getOptions(filter) {\n        return this._documentRootLocator.locatorForAll(this._optionClass.with({\n            ...(filter || {}),\n            ancestor: await this._getPanelSelector(),\n        }))();\n    }\n    /** Gets the groups of options inside the panel. */\n    async getOptionGroups(filter) {\n        return this._documentRootLocator.locatorForAll(this._optionGroupClass.with({\n            ...(filter || {}),\n            ancestor: await this._getPanelSelector(),\n        }))();\n    }\n    /** Gets whether the select is open. */\n    async isOpen() {\n        return !!(await this._documentRootLocator.locatorForOptional(await this._getPanelSelector())());\n    }\n    /** Opens the select's panel. */\n    async open() {\n        if (!(await this.isOpen())) {\n            const trigger = await this.locatorFor(`.${this._prefix}-select-trigger`)();\n            return trigger.click();\n        }\n    }\n    /**\n     * Clicks the options that match the passed-in filter. If the select is in multi-selection\n     * mode all options will be clicked, otherwise the harness will pick the first matching option.\n     */\n    async clickOptions(filter) {\n        await this.open();\n        const [isMultiple, options] = await parallel(() => [\n            this.isMultiple(),\n            this.getOptions(filter),\n        ]);\n        if (options.length === 0) {\n            throw Error('Select does not have options matching the specified filter');\n        }\n        if (isMultiple) {\n            await parallel(() => options.map(option => option.click()));\n        }\n        else {\n            await options[0].click();\n        }\n    }\n    /** Closes the select's panel. */\n    async close() {\n        if (await this.isOpen()) {\n            // This is the most consistent way that works both in both single and multi-select modes,\n            // but it assumes that only one overlay is open at a time. We should be able to make it\n            // a bit more precise after #16645 where we can dispatch an ESCAPE press to the host instead.\n            return (await this._backdrop()).click();\n        }\n    }\n    /** Gets the selector that should be used to find this select's panel. */\n    async _getPanelSelector() {\n        const id = await (await this.host()).getAttribute('id');\n        return `#${id}-panel`;\n    }\n}\n/** Harness for interacting with a standard mat-select in tests. */\nclass MatSelectHarness extends _MatSelectHarnessBase {\n    constructor() {\n        super(...arguments);\n        this._prefix = 'mat';\n        this._optionClass = MatOptionHarness;\n        this._optionGroupClass = MatOptgroupHarness;\n    }\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatSelectHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which select instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options = {}) {\n        return new HarnessPredicate(MatSelectHarness, options);\n    }\n}\nMatSelectHarness.hostSelector = '.mat-select';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport { MatSelectHarness, _MatSelectHarnessBase };\n"]},"metadata":{},"sourceType":"module"}